clear functions % This line is really needed!close allclear all%%%%%%%%% INITIALIZE PARAMETERS %%%%%%%Mechanical parameters.m  =  1;    % m2 =  1;  % masses%  I1  =  5*eye(3); I1 = [5 1.5 1.4;     1.5 3 0.5;     1.4 0.5 4];xG  = 0.1;yG  = 0.2;zG  = 0.3;lCuboid = 0.3;%长方体的长wCuboid = 0.2;%长方体的宽hCuboid = 0.1;%长方体的高% I2 = 5*eye(3);  % inertias about cms% l   =  1;              % length of links% a   =  .5;            % dist. from O to G1 and E to G2 (see figures)g   =  1;% Initial conditions and other settings.framespersec=50;  %if view is not speeded or slowed in dbpend_animateT=5;             %duration of animation  in secondstspan=linspace(0,T,T*framespersec);q1    = 0; %xbq2    = 0.0; %ybq3    = 2.0; %zbq4    = pi/3; %qxq5    = pi/6; %qyq6    = pi/5; %qzu1    = 0.0; %xbd  u2    = 0.0; %ybdu3    = 0.0; %zbdu4    = 1;%qxdu5    = 2;%qydu6    = 3;%qzdz0=[q1 u1 q2 u2 q3 u3 q4 u4 q5 u5 q6 u6]';options=odeset('abstol',1e-9,'reltol',1e-9);%%%%%%% INTEGRATOR or ODE SOLVER %%%%%%%[t z] = ode113('rhs',tspan,z0,options, ...                          m,xG,yG,zG,I1,g);%%%%%%% POSTPROCESSING %%%%%%%%%%%%%%%%% A routine to animate the results% To speed up change the framespersecondnfig=0;nfig=nfig+1;figure(nfig)for i=1:6%基座坐标系原点位置和欧拉角subplot(2,3,i);plot(t,z(:,i));endnfig=nfig+1;figure(nfig)for i=1:6%基座坐标系原点速度和欧拉角速度subplot(2,3,i);plot(t,z(:,6+i));end%%求解出浮动基坐标系、质心坐标系、长方体顶点位置，做动画nfig=nfig+1;figure(nfig)for i=1:length(t)      pause(.005)    [pFb, pFbx, pFby, pFbz, pG, pGx, pGy, pGz, p1, p2, p3, p4, p5, p6, p7, p8] = draw_fb(t,z(i,:),xG,yG,zG,lCuboid, wCuboid, hCuboid);    surf1.X=[p1(1) p2(1) p3(1) p4(1)];    surf1.Y=[p1(2) p2(2) p3(2) p4(2)];    surf1.Z=[p1(3) p2(3) p3(3) p4(3)];    fill3(surf1.X, surf1.Y, surf1.Z,'r')    hold on    surf2.X=[p1(1) p4(1) p8(1) p5(1)];    surf2.Y=[p1(2) p4(2) p8(2) p5(2)];    surf2.Z=[p1(3) p4(3) p8(3) p5(3)];    fill3(surf2.X, surf2.Y, surf2.Z,'g')     hold on    surf3.X=[p3(1) p4(1) p8(1) p7(1)];    surf3.Y=[p3(2) p4(2) p8(2) p7(2)];    surf3.Z=[p3(3) p4(3) p8(3) p7(3)];    fill3(surf3.X, surf3.Y, surf3.Z,'b')    hold on    surf4.X=[p6(1) p5(1) p8(1) p7(1)];    surf4.Y=[p6(2) p5(2) p8(2) p7(2)];    surf4.Z=[p6(3) p5(3) p8(3) p7(3)];    fill3(surf4.X, surf4.Y, surf4.Z,'r')    hold on    surf5.X=[p6(1) p2(1) p3(1) p7(1)];    surf5.Y=[p6(2) p2(2) p3(2) p7(2)];    surf5.Z=[p6(3) p2(3) p3(3) p7(3)];    fill3(surf5.X, surf5.Y, surf5.Z,'g')    hold on    surf6.X=[p6(1) p2(1) p1(1) p5(1)];    surf6.Y=[p6(2) p2(2) p1(2) p5(2)];    surf6.Z=[p6(3) p2(3) p1(3) p5(3)];    fill3(surf6.X, surf6.Y, surf6.Z,'b')    hold on    plot3([pFb(1) pFbx(1)],[pFb(2) pFbx(2)],[pFb(3) pFbx(3)],'r')%画出基座坐标系    hold on   plot3([pFb(1) pFby(1)],[pFb(2) pFby(2)],[pFb(3) pFby(3)],'b')   hold on   plot3([pFb(1) pFbz(1)],[pFb(2) pFbz(2)],[pFb(3) pFbz(3)],'g')   hold on   plot3([pG(1) pGx(1)],[pG(2) pGx(2)],[pG(3) pGx(3)],'r')%画出质心坐标系   hold on   plot3([pG(1) pGy(1)],[pG(2) pGy(2)],[pG(3) pGy(3)],'b')   hold on   plot3([pG(1) pGz(1)],[pG(2) pGz(2)],[pG(3) pGz(3)],'g')      hold on   plot3([0 1],[0,0],[0,0],'r')   hold on   plot3([0 0],[0,1],[0,0],'b')   hold on   plot3([0 0],[0,0],[0,1],'g')   %此处不能用quiver3，因为它的参数不是两个点%    quiver3(pFb(1),pFb(2),pFb(3),pFbx(1),pFbx(2),pFbx(3));%画出基座坐标系%    quiver3(pFb(1),pFb(2),pFb(3),pFby(1),pFby(2),pFby(3));%    quiver3(pFb(1),pFb(2),pFb(3),pFbz(1),pFbz(2),pFbz(3));%    hold on%    quiver3(pG(1),pG(2),pG(3),pGx(1),pGx(2),pGx(3));%画出质心坐标系%    quiver3(pG(1),pG(2),pG(3),pGy(1),pGy(2),pGy(3));%    quiver3(pG(1),pG(2),pG(3),pGz(1),pGz(2),pGz(3));    hold off    axis([0 2 0 2 -1 2]);    axis square    xlabel('x'); ylabel('y'); zlabel('z');end%%% 看动画时候，看着浮动基坐标系、质心坐标系三轴不正交，二者也不平行，因此用点乘和叉乘判断是否正交和平行nfig=nfig+1;figure(nfig)for i=1:length(t)    [pFb, pFbx, pFby, pFbz, pG, pGx, pGy, pGz, p1, p2, p3, p4, p5, p6, p7, p8] = draw_fb(t,z(i,:),xG,yG,zG,lCuboid, wCuboid, hCuboid);    Gxy(i)=dot(pGx-pG,pGy-pG);%质心坐标系x和y轴，点乘=0，则垂直    Gzy(i)=dot(pGz-pG,pGy-pG);    Gxz(i)=dot(pGx-pG,pGz-pG);    Bxy(i)=dot(pFbx-pFb,pFby-pFb);%浮动基坐标系x和y轴，点乘=0，则垂直    Bzy(i)=dot(pFbz-pFb,pFby-pFb);    Bxz(i)=dot(pFbx-pFb,pFbz-pFb);    BGxx(i) = max(cross(pGx-pG,pFbx-pFb));%浮动基x轴和质心坐标系x轴，叉乘得到一个向量，如果向量的最大值为0，说明向量为0，则平行    BGyy(i) = max(cross(pGy-pG,pFby-pFb));    BGzz(i) = max(cross(pGz-pG,pFbz-pFb));endsubplot(3,3,1);plot(t,Gxy)subplot(3,3,2);plot(t,Gzy)subplot(3,3,3);plot(t,Gxz)subplot(3,3,4);plot(t,Bxy)subplot(3,3,5);plot(t,Bzy)subplot(3,3,6);plot(t,Bxz)subplot(3,3,7);plot(t,BGxx)subplot(3,3,8);plot(t,BGyy)subplot(3,3,9);plot(t,BGzz)%%% energy check, Total energy should be constant%%% here we plot successive difference in total energies (should be zero)%%% NOTE: %%% a) energy difference can not be better than the ode tolerance. %%%    This is one way to check if simulations are alright. %%% b) This is not true if the system is actuated or there are dissipative%%%    forces like dampers. The TE here consists of conservative forces. nfig=nfig+1;figure(nfig)for i=1:length(t)    [KE(i), PE(i)] = energy(t(i),z(i,:),m,xG,yG,zG,I1,g);endTE = KE + PE;TE_diff = diff(TE);subplot(1,2,1);plot(t(1:end-1),TE_diff)title('TE diff')subplot(1,2,2);plot(t,KE,'r.',t,PE,'b*')title('KE and PE')%%% Angular Momentum check, 绕质心的外力矩为0，所以绕质心的角动量守恒nfig=nfig+1;figure(nfig)for i=1:length(t)[AM(i,1) AM(i,2) AM(i,3)]=AngularMomentum(t(i),z(i,:),m,xG,yG,zG,I1,g);%角动量endsubplot(2,3,1);plot(t,AM(:,1))title('AM along x axis')subplot(2,3,2);plot(t,AM(:,2))title('AM along y axis')subplot(2,3,3);plot(t,AM(:,3))title('AM along z axis')subplot(2,3,4);AM_diff = diff(AM(:,1));%检查角动量是否守恒plot(t(1:end-1),AM_diff)title('AM diff along x axis')subplot(2,3,5);AM_diff = diff(AM(:,2));plot(t(1:end-1),AM_diff)title('AM diff along y axis')subplot(2,3,6);AM_diff = diff(AM(:,3));plot(t(1:end-1),AM_diff)title('AM diff along z axis') 